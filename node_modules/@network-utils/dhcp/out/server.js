"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const enum_1 = require("./enum");
const option_1 = require("./option");
const packet_1 = require("./packet");
const socket_1 = require("./socket");
class Server extends socket_1.Socket {
    constructor(param) {
        super("udp4", 67, 68);
        this.ipAddress = {
            min: 10,
            max: 244,
        };
        this.netmask = "255.255.255.0";
        this.addressTime = 86400; // 1 day
        this.domainServer = [];
        this.gateways = [];
        if (typeof param === "string") {
            this.serverId = param;
        }
        else {
            this.serverId = param.serverId;
            if (param.ipAddress) {
                if (param.ipAddress.min) {
                    this.ipAddress.min = param.ipAddress.min;
                }
                if (param.ipAddress.max) {
                    this.ipAddress.max = param.ipAddress.max;
                }
            }
            if (param.netmask) {
                this.netmask = param.netmask;
            }
            if (param.addressTime) {
                this.addressTime = param.addressTime;
            }
            if (param.domainServer) {
                this.domainServer = param.domainServer;
            }
            if (param.gateways) {
                this.gateways = param.gateways;
            }
        }
        this.on("dhcp", (e) => {
            const packet = e.packet;
            if (packet.op === enum_1.BOOTMessageType.request) {
                const event = {
                    packet, target: this,
                };
                this.emit(enum_1.DHCPMessageType[packet.type], event);
            }
        });
    }
    on() {
        return super.on.apply(this, arguments);
    }
    once() {
        return super.once.apply(this, arguments);
    }
    /**
     * Creates DHCP Offer Packet
     *
     * @param {Packet} request
     * @returns
     *
     * @memberOf Server
     */
    createOffer(request) {
        const p = new packet_1.Packet();
        p.op = enum_1.BOOTMessageType.reply;
        p.giaddr = request.giaddr;
        p.xid = request.xid;
        p.flags = request.flags;
        p.chaddr = request.chaddr;
        p.options.push(new option_1.DHCPMessageTypeOption(enum_1.DHCPMessageType.offer)); // #53
        p.options.push(new option_1.SubnetMaskOption(this.netmask)); // #1
        if (this.gateways.length) {
            p.options.push(new option_1.GatewaysOption(this.gateways));
        } // #3
        if (this.domainServer.length) {
            p.options.push(new option_1.DomainServerOption(this.domainServer));
        } // #6
        p.options.push(new option_1.AddressTimeOption(this.addressTime)); // #51
        p.options.push(new option_1.DHCPServerIdOption(this.serverId)); // #54
        return p;
    }
    /**
     * Creates DHCP Ack Packet
     *
     * @param {Packet} pocket
     * @returns
     *
     * @memberOf Server
     */
    createAck(pocket) {
        const p = new packet_1.Packet();
        p.op = enum_1.BOOTMessageType.reply;
        p.xid = pocket.xid;
        p.ciaddr = pocket.giaddr;
        p.giaddr = pocket.giaddr;
        p.flags = pocket.flags;
        p.chaddr = pocket.chaddr;
        p.options.push(new option_1.DHCPMessageTypeOption(enum_1.DHCPMessageType.ack)); // #53
        p.options.push(new option_1.SubnetMaskOption(this.netmask)); // #1
        if (this.gateways.length) {
            p.options.push(new option_1.GatewaysOption(this.gateways));
        } // #3
        if (this.domainServer.length) {
            p.options.push(new option_1.DomainServerOption(this.domainServer));
        } // #6
        if (pocket.type === enum_1.DHCPMessageType.request) {
            p.options.push(new option_1.AddressTimeOption(this.addressTime));
        } // #51
        p.options.push(new option_1.DHCPServerIdOption(this.serverId)); // #54
        return p;
    }
    /**
     * Creates DHCP Nak Packet
     *
     * @param {Packet} pocket
     * @returns
     *
     * @memberOf Server
     */
    createNak(pocket) {
        const p = new packet_1.Packet();
        p.op = enum_1.BOOTMessageType.reply;
        p.xid = pocket.xid;
        p.giaddr = pocket.giaddr;
        p.options.push(new option_1.DHCPMessageTypeOption(enum_1.DHCPMessageType.nak)); // #53
        p.options.push(new option_1.DHCPServerIdOption(this.serverId)); // #54
        return p;
    }
}
exports.Server = Server;
